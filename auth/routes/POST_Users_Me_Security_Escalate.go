package routes

import (
	"database/sql"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"dsoob/backend/tools"
)

func POST_Users_Me_Security_Escalate(w http.ResponseWriter, r *http.Request) {

	var Body struct {
		Passcode string `json:"passcode" validate:"omitempty,passcode"`
	}
	if !tools.BindJSON(w, r, &Body) {
		return
	}
	session := tools.GetSession(r)

	// Fetch Account with MFA Fields
	var (
		UserEmailAddress            string
		UserEmailVerified           bool
		UserMFAEnabled              bool
		UserMFASecret               *string
		UserMFACodesRAW             string
		UserMFACodesUsed            int
		UserPasswordHash            *string
		UserEmailPasscode           *string
		UserEmailPasscodeExpiration *time.Time
	)
	err := tools.Database.QueryRowContext(r.Context(),
		`SELECT
			email_address, email_verified, mfa_enabled,
			mfa_secret, mfa_codes, mfa_codes_used,
			password_hash, token_passcode, token_passcode_eat
		FROM user WHERE id = $1`,
		session.UserID,
	).Scan(
		&UserEmailAddress,
		&UserEmailVerified,
		&UserMFAEnabled,
		&UserMFASecret,
		&UserMFACodesRAW,
		&UserMFACodesUsed,
		&UserPasswordHash,
		&UserEmailPasscode,
		&UserEmailPasscodeExpiration,
	)
	if errors.Is(err, sql.ErrNoRows) {
		tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
		return
	}
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Attempt Multi-Factor Authentication
	if UserMFAEnabled && UserMFASecret != nil {

		// Method: TOTP Verification
		// User must prove their ownership by entering a code generated by an external application
		// or by entering a unused recovery code

		if Body.Passcode == "" {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_REQUIRED)
			return
		}

		switch len(Body.Passcode) {

		// Using Passcode
		case tools.MFA_PASSCODE_LENGTH:
			if !tools.ValidateTOTPCode(Body.Passcode, *UserMFASecret) {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}

		// Using Recovery Code
		case tools.MFA_RECOVERY_LENGTH:
			found := false
			for i, recoveryCode := range strings.Split(UserMFACodesRAW, tools.ARRAY_DELIMITER) {
				if Body.Passcode == recoveryCode {

					// Code Used?
					if (UserMFACodesUsed & (1 << i)) != 0 {
						tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_USED)
						return
					}

					// Mark Recovery Code as Used
					if _, err := tools.Database.ExecContext(r.Context(),
						"UPDATE user SET mfa_codes_used = mfa_codes_used | $1 WHERE id = $2",
						(1 << i),
						session.UserID,
					); err != nil {
						tools.SendServerError(w, r, err)
						return
					}

					found = true
					break
				}
			}
			if !found {
				tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_INCORRECT)
				return
			}

		default:
			// Should have been caught by the validator!
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
			return
		}

	} else if UserEmailVerified {

		// Method: Email Verification
		// User must prove their ownership by entering a passcode sent to the email address on file

		if Body.Passcode == "" {

			// Update User
			var (
				NewPasscode           = tools.GeneratePasscode()
				NewPasscodeExpiration = time.Now().Add(tools.LIFETIME_TOKEN_EMAIL_PASSCODE)
			)
			if _, err = tools.Database.ExecContext(r.Context(),
				`UPDATE user SET
					updated 		   = CURRENT_TIMESTAMP,
					token_passcode 	   = $1,
					token_passcode_eat = $2
				WHERE id = $3`,
				NewPasscode,
				NewPasscodeExpiration,
				session.UserID,
			); err != nil {
				tools.SendServerError(w, r, err)
				return
			}

			// Notify User
			go tools.EmailLoginPasscode(
				UserEmailAddress,
				tools.LocalsLoginPasscode{
					Code:     NewPasscode,
					Lifetime: fmt.Sprint(tools.LIFETIME_TOKEN_EMAIL_PASSCODE.Minutes()),
				},
			)

			tools.SendClientError(w, r, tools.ERROR_MFA_EMAIL_SENT)
			return

		} else {

			// Match Passcode
			if !strings.EqualFold(Body.Passcode, *UserEmailPasscode) {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}

		}

	} else if UserPasswordHash != nil {

		// Method: Password
		// User must prove their ownership by entering their password
		if match, err := tools.ComparePasswordHash(*UserPasswordHash, Body.Passcode); err != nil {
			tools.SendServerError(w, r, err)
			return
		} else if !match {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSWORD_INCORRECT)
			return
		}

	} else {

		// Method: None
		// User cannot prove their ownership of this account as theirs
		tools.SendClientError(w, r, tools.ERROR_LOGIN_PASSWORD_RESET)
		return
	}

	// Mark Current Session as Elevated
	elevatedUntil := time.Now().Add(tools.LIFETIME_TOKEN_USER_ELEVATION)
	if _, err := tools.Database.ExecContext(r.Context(),
		"UPDATE user_session SET elevated_until = $1 WHERE id = $2",
		elevatedUntil,
		session.SessionID,
	); err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Return Results
	tools.SendJSON(w, r, http.StatusOK, map[string]any{
		"elevated_until": elevatedUntil.Unix(),
	})
}

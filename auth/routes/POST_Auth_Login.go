package routes

import (
	"database/sql"
	"errors"
	"net/http"
	"strings"
	"time"

	"dsoob/backend/tools"
)

func POST_Auth_Login(w http.ResponseWriter, r *http.Request) {

	var Body struct {
		Email     string `json:"email" validate:"required,email"`
		Password  string `json:"password" validate:"required"`
		Passcode  string `json:"passcode" validate:"omitempty,passcode"`
		PublicKey string `json:"public_key" validate:"required,publickey"`
	}
	if !tools.BindJSON(w, r, &Body) {
		return
	}

	// Find Relevant Account
	var (
		UserID            int64
		UserEmailAddress  string
		UserEmailVerified bool
		UserIPAddress     string
		UserMFAEnabled    bool
		UserMFASecret     *string
		UserMFACodesRAW   string
		UserMFACodesUsed  int
		UserPasswordHash  *string
	)
	err := tools.Database.QueryRowContext(r.Context(),
		`SELECT
			id, email_address, email_verified, ip_address,
			mfa_enabled, mfa_secret, mfa_codes, mfa_codes_used,
			password_hash
		FROM user WHERE email_address = LOWER(?)`,
		Body.Email,
	).Scan(
		&UserID, &UserEmailAddress, &UserEmailVerified, &UserIPAddress,
		&UserMFAEnabled, &UserMFASecret, &UserMFACodesRAW, &UserMFACodesUsed,
		&UserPasswordHash,
	)
	if errors.Is(err, sql.ErrNoRows) {
		tools.SendClientError(w, r, tools.ERROR_LOGIN_INCORRECT)
		return
	}
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Validate Password
	if UserPasswordHash == nil {
		tools.SendClientError(w, r, tools.ERROR_LOGIN_PASSWORD_RESET)
		return
	}
	if ok, err := tools.ComparePasswordHash(*UserPasswordHash, Body.Password); err != nil {
		tools.SendServerError(w, r, err)
		return
	} else if !ok {
		tools.SendClientError(w, r, tools.ERROR_LOGIN_INCORRECT)
		return
	}

	// Filter: Multi-Factor Authentication
	var (
		SessionID        = tools.GenerateSnowflake()
		SessionCreated   = time.Now()
		SessionUserAgent = r.UserAgent()
		SessionAddress   = tools.GetRemoteIP(r)
		SessionToken     = tools.GenerateSignedString()
	)
	if UserMFAEnabled && UserMFASecret != nil {

		// Method: TOTP Verification
		// User must attempt to prove ownership by entering a code generated by
		// their authenticator app or by entering a recovery code

		if Body.Passcode == "" {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_REQUIRED)
			return
		}

		switch len(Body.Passcode) {

		// Using Passcode
		case tools.MFA_PASSCODE_LENGTH:
			if !tools.ValidateTOTPCode(Body.Passcode, *UserMFASecret) {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}

		// Using Recovery Code
		case tools.MFA_RECOVERY_LENGTH:
			found := false
			for i, recoveryCode := range strings.Split(UserMFACodesRAW, tools.ARRAY_DELIMITER) {
				if Body.Passcode == recoveryCode {

					// Code Used?
					if (UserMFACodesUsed & (1 << i)) != 0 {
						tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_USED)
						return
					}

					// Mark Recovery Code as Used
					if _, err := tools.Database.ExecContext(r.Context(),
						"UPDATE user SET mfa_codes_used = mfa_codes_used | ? WHERE id = ?",
						(1 << i),
						UserID,
					); err != nil {
						tools.SendServerError(w, r, err)
						return
					}

					found = true
					break
				}
			}
			if !found {
				tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_INCORRECT)
				return
			}

		default:
			// Should have been caught by the validator!
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
			return
		}

	} else if UserEmailVerified && !tools.CompareStringConstant(UserIPAddress, SessionAddress) {

		// Method: Allow Login
		// User must allow this unknown new location access to their account by
		// clicking on a button sent to their email address

		// Generate Token
		var UserLoginVerifyToken = tools.GenerateSignedString()
		tag, err := tools.Database.ExecContext(r.Context(),
			`UPDATE user SET
				updated 		 = CURRENT_TIMESTAMP,
				token_login 	 = ?,
				token_login_data = ?,
				token_login_eat  = ?
			WHERE id = ?`,
			UserLoginVerifyToken,
			SessionAddress,
			time.Now().Add(tools.LIFETIME_TOKEN_EMAIL_LOGIN),
			UserID,
		)
		if err != nil {
			tools.SendServerError(w, r, err)
			return
		}
		if c, err := tag.RowsAffected(); err != nil {
			tools.SendServerError(w, r, err)
			return
		} else if c == 0 {
			tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
			return
		}

		// Alert User
		go tools.EmailLoginNewLocation(
			UserEmailAddress,
			tools.LocalsLoginNewLocation{
				Token:          UserLoginVerifyToken,
				IpAddress:      SessionAddress,
				Timestamp:      tools.LookupTimezone(time.Now(), SessionAddress),
				DeviceBrowser:  tools.LookupBrowser(SessionUserAgent),
				DeviceLocation: tools.LookupLocation(SessionAddress),
			},
		)

		tools.SendClientError(w, r, tools.ERROR_MFA_EMAIL_SENT)
		return
	}

	// Update User
	tag, err := tools.Database.ExecContext(r.Context(),
		`UPDATE user SET
			updated    = CURRENT_TIMESTAMP,
			ip_address = ?
		WHERE id = ?`,
		SessionAddress,
		UserID,
	)
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}
	if c, err := tag.RowsAffected(); err != nil {
		tools.SendServerError(w, r, err)
		return
	} else if c == 0 {
		tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
		return
	}

	// Create Session
	_, err = tools.Database.ExecContext(r.Context(),
		`INSERT INTO user_session (
			id, created, user_id, token, device_ip_address, device_user_agent, device_public_key
		) VALUES (?, ?, ?, ?, ?, ?, ?)`,
		SessionID,
		SessionCreated,
		UserID,
		SessionToken,
		SessionAddress,
		SessionUserAgent,
		Body.PublicKey,
	)
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Alert User
	go tools.EmailLoginNewDevice(
		UserEmailAddress,
		tools.LocalsLoginNewDevice{
			IpAddress:      SessionAddress,
			Timestamp:      tools.LookupTimezone(time.Now(), SessionAddress),
			DeviceBrowser:  tools.LookupBrowser(SessionUserAgent),
			DeviceLocation: tools.LookupLocation(SessionAddress),
		},
	)

	// Send Results
	tools.SendJSON(w, r, http.StatusOK, map[string]any{
		"user_id":    UserID,
		"session_id": SessionID,
		"prefix":     tools.TOKEN_PREFIX_USER,
		"token":      SessionToken,
	})
}

package tools

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"sync"
)

// NOTE: Intended for small and simple file operations :)

var (
	ErrStorageFileNotFound    = errors.New("file not found")
	ErrStorageInvalidFilename = errors.New("filename contains invalid characters")

	storageAccessKey string // Access Key ID
	storageSecretKey string // Access Key Secret
	storageRegion    string // Bucket Region
	storageHost      string // Bucket Host
)

func StorageSetup(stop context.Context, await *sync.WaitGroup) {

	// Prepare Client
	s3url, err := url.Parse(STORAGE_S3_ENDPOINT)
	if err != nil {
		LoggerStorage.Log(FATAL, "Invalid S3 Endpoint URL: %s", err)
	}
	storageAccessKey = STORAGE_S3_KEY_ACCESS
	storageSecretKey = STORAGE_S3_KEY_SECRET
	storageRegion = STORAGE_S3_REGION
	storageHost = s3url.Host

	// Test Client
	ctx, cancel := NewContext()
	defer cancel()

	filename := fmt.Sprintf("_test/__%d__", GenerateSnowflake())
	filedata := "Don't worry you aren't being hacked!" +
		" This file was generated by the backend on startup to ensure it has write access to the S3 Bucket." +
		" If you're seeing this most likely the process was killed during startup." +
		" You can safely delete me :)"

	if err := StoragePut(ctx, filename, "text/plain", []byte(filedata)); err != nil {
		LoggerStorage.Log(FATAL, "Insufficient permissions need WRITE access; %s", err)
	}
	if r, err := StorageGet(ctx, filename); err != nil {
		LoggerStorage.Log(FATAL, "Insufficient permissions need READ access; %s", err)
	} else {
		r.Close()
	}
	if err := StorageDelete(ctx, filename); err != nil {
		LoggerStorage.Log(FATAL, "Insufficient permissions need DELETE access: %s", err)
	}
}

func StoragePut(ctx context.Context, key, contentType string, data []byte) error {

	// Generate Request
	url := fmt.Sprint("https://", storageHost, "/", key)
	req, err := http.NewRequestWithContext(ctx, http.MethodPut, url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Add("Content-Type", contentType)
	AmazonSignRequestV4(req, data, storageAccessKey, storageSecretKey, storageHost, storageRegion, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ := io.ReadAll(res.Body)
		return fmt.Errorf("put failed: %d: %s", res.StatusCode, string(body))
	}

	return nil
}

func StorageGet(ctx context.Context, key string) (io.ReadCloser, error) {

	// Generate Request
	url := fmt.Sprint("https://", storageHost, "/", key)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
	if err != nil {
		return nil, err
	}
	AmazonSignRequestV4(req, []byte{}, storageAccessKey, storageSecretKey, storageHost, storageRegion, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	if res.StatusCode == 404 {
		return nil, ErrStorageFileNotFound
	}
	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ := io.ReadAll(res.Body)
		return nil, fmt.Errorf("get failed: %d: %s", res.StatusCode, string(body))
	}

	return res.Body, nil
}

func StorageDelete(ctx context.Context, keys ...string) error {

	// Generate Body
	var buffer bytes.Buffer
	buffer.WriteString("<Delete xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">")
	for _, k := range keys {
		fmt.Fprintf(&buffer, "<Object><Key>%s</Key></Object>", html.EscapeString(k))
	}
	buffer.WriteString("</Delete>")
	body := buffer.Bytes()

	// Generate Request
	url := fmt.Sprint("https://", storageHost, "/?delete")
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, &buffer)
	if err != nil {
		return err
	}
	AmazonSignRequestV4(req, body, storageAccessKey, storageSecretKey, storageHost, storageRegion, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ = io.ReadAll(res.Body)
		return fmt.Errorf("server responded with status %d: %s", res.StatusCode, string(body))
	}

	return nil
}

package tools

import (
	"crypto/md5"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"
	"time"

	"golang.org/x/crypto/bcrypt"
)

var (
	hashSemaphore = make(chan struct{}, PASSWORD_CONCURRENT_LIMIT)
)

// Picks a Random Number between for Email One-Time Passcodes
func GeneratePasscode() string {
	n, err := rand.Int(rand.Reader, big.NewInt(1000000))
	if err != nil {
		panic(err)
	}
	return fmt.Sprintf("%06d", n)
}

// Generate Six 8-Character Recovery Codes for MFA Setup
func GenerateRecoveryCodes() []string {
	codes := make([]string, 6)
	for i := range codes {
		b := make([]byte, 4)
		if _, err := io.ReadFull(rand.Reader, b); err != nil {
			panic(err)
		}
		codes[i] = fmt.Sprintf("%X", b)
	}
	return codes
}

// Generate a random string to be used as a token. Additionally the string is generally unique.
func GenerateTokenString() string {

	b := make([]byte, TOKEN_BYTE_LENGTH)
	n := binary.PutVarint(b, time.Now().Unix()-EPOCH_SECONDS)
	if _, err := io.ReadFull(rand.Reader, b[n:]); err != nil {
		panic(err)
	}

	return base64.RawURLEncoding.EncodeToString(b)
}

// Ensure that the given string was probably generated by the server
func CompareTokenString(givenString string) bool {

	givenBytes, err := base64.RawURLEncoding.DecodeString(givenString)
	if err != nil {
		return false
	}

	return len(givenBytes) == TOKEN_BYTE_LENGTH
}

// Wrapper to Hash Password with Predefined Effort
func GeneratePasswordHash(givenPassword string) (string, error) {
	hashSemaphore <- struct{}{}
	defer func() { <-hashSemaphore }()

	hashBytes, err := bcrypt.GenerateFromPassword(
		[]byte(givenPassword),
		PASSWORD_HASH_EFFORT,
	)
	if err != nil {
		return "", err
	}
	return string(hashBytes), nil
}

// Wrapper to Compare Password Against Given String
func ComparePasswordHash(givenHash, givenPassword string) (bool, error) {
	hashSemaphore <- struct{}{}
	defer func() { <-hashSemaphore }()

	err := bcrypt.CompareHashAndPassword(
		[]byte(givenHash),
		[]byte(givenPassword),
	)
	if errors.Is(err, bcrypt.ErrMismatchedHashAndPassword) {
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return true, nil
}

// Compare two strings in constant time to prevent leaking of sensitive info
func CompareStringConstant(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}

// Generate Standard Hash for an Image
func GenerateImageHash(image []byte) string {
	return fmt.Sprintf("%x", md5.Sum(image))
}
